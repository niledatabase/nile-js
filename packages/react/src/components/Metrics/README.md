# Metrics

> **_NOTE:_** This is a work in progress, and requires metrics to be populated within a given workspace. See more about producing metrics: [producing metrics in the api](https://www.thenile.dev/rest-api#tag/metrics/operation/produceBatchOfMetrics). In the sdk, `nile.metrics.produceBatchOfMetrics(payload)` can be used to produce them. In addition, metrics are autogenerated when actions are performed on entities.

Metrics come in two flavors, timeseries charts and hooks to handles requesting and formatting metrics to be rendered.

## Storybook

https://storybook.thenile.dev/

## Components

### MetricsLineChart

The chart renders a single line. Provide either a `filter` object or an `aggregation` object depending on what needs to be rendered.

> For an ajustable start time, use `<StartTime />`

#### Usage

```typescript
import { MetricsLineChart, NileProvider } from '@theniledev/react';

const WORKSPACE = 'myWorkspace'; // name of the workspace to use

function App() {
  const filter = {
    entityType: 'clusters',
    metricName: 'my.metric',
  };
  const aggregation = {
    aggregationRequest: {
      startTime: new Date(),
      organizationId: 'myOrganization',
      bucketSize: '1h',
    },
    metricName: 'my.metric',
    aggregationType: 'sum',
  };
  return (
    <NileProvider workspace={WORKSPACE}>
      <h1>ðŸ¤©Metrics the greatðŸ¤©</h1>
      <h2>Requests</h2>
      <MetricsLineChart filter={filter} />
      <MetricsLineChart aggregation={aggregation} />
    </NileProvider>
  );
}
```

### MetricsBarChart

A timeseries chart renders a bar graph. Useful for viewing build-in metrics. Provide either a `filter` object or an `aggregation` object depending on what needs to be rendered.

#### Usage

```typescript
import { MetricsBarChart, NileProvider } from '@theniledev/react';

const WORKSPACE = 'myWorkspace'; // name of the workspace to use

function App() {
  const filter = {
    entityType: 'clusters',
    metricName: 'my.metric',
  };
  const aggregation = {
    aggregationRequest: {
      startTime: new Date(),
      organizationId: 'myOrganization',
      bucketSize: '1h',
    },
    metricName: 'my.metric',
    aggregationType: 'sum',
  };
  return (
    <NileProvider workspace={WORKSPACE}>
      <h1>ðŸ¤©Metrics the greatðŸ¤©</h1>
      <h2>Requests</h2>
      <MetricsBarChart filter={filter} />
      <MetricsBarChart aggregation={aggregation} />
    </NileProvider>
  );
}
```

#### Properties

**dataset** object

- A configuration object to render the line. Maps to [chartjs dataset configuration](https://www.chartjs.org/docs/latest/configuration/#dataset-configuration)

This dataset will vary based on the type of chart.

**chartOptions**

- A configuration object to render the graph. Maps to [chartjs chart configuration](https://www.chartjs.org/docs/latest/configuration/#configuration-object-structure)

**emptyState**

- Overrides the default JSX.Element rendered when the chart is empty.

#### StartTime

If you want to provide users with a time series where they can select a start time to browse metrics, use the `<StartTime />` component. The value set will apply to all charts.

#### IntervalSelect

Auto-refreshing is made possible via an `IntervalSelect` dropdown. By default, refreshing is not enabled. To enable it, include the `<IntervalSelect />` component, which will allow users to set 30s, 1m or 5m refreshing. The default is 1 minute. Just like `<StartTime />` this value is set for all charts.

## Hooks

It is expected that the basic charts provided by this library will not meet the needs of every use case. For custom charts, the `useFilter` and/or the `useAggregation` hooks can be used to request and format data, and then iterated on.

### useFilter

Assuming a metric is being produced of uptime 1 being up and 0 being down...

```typescript
function MyMetricComponent() {

  const { metrics } = useFilter({
    filter: {
      startTime: new Date(), // start reading metrics from right now
      metricName: 'uptime',
      entityType: 'DB',
    },
  });

  return (
    <div>
      {metrics?.map((metric, idx)=> {
        if (metric.value === 0) {
          return <div key={idx}>ðŸ¤ª Oh nooo! It's broked ðŸ¤ª</div>;
        }
        return (
          <div key={idx}>
            This is working <strong>very</strong> well
          </div>
        );
      })}
    </div>
    );
  }
}
```

### useAggregation

```typescript
function MyMetricComponent() {

  const { buckets } = useAggregation({
    aggregationRequest: {
      startTime: new Date(),
      organizationId: 'myOrganization',
      bucketSize: '1h',
    },
    metricName: 'my.metric',
  });

  return (
    <div>
      {buckets?.map((bucket, idx)=> {
        return (
          <div key={idx}>
            min: {bucket.min}
            max: {bucket.max}
            sum: {bucket.sum}
            average: {bucket.average}
            percentile95: {bucket.percentile95}
          </div>
        );
      })}
    </div>
    );
  }
}
```
