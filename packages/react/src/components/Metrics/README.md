# Metrics

> **_NOTE:_** This is a work in progress, and requires metrics to be populated within a given workspace. See more about producing metrics: [producing metrics in the api](https://www.thenile.dev/rest-api#tag/metrics/operation/produceBatchOfMetrics). In the sdk, `nile.metrics.produceBatchOfMetrics(payload)` can be used to produce them. In addition, metrics are autogenerated when actions are performed on entities.

Metrics come in two flavors, timeseries charts and hooks to handles requesting and formatting metrics to be rendered.

## Storybook

https://storybook.thenile.dev/

## Charts

### MetricsLineChart

The chart renders a single line. Provide either a `filter` object or an `aggregation` object depending on what needs to be rendered.

> For an ajustable start time, use `<StartTime />`

#### Usage

```typescript
import { MetricsLineChart, NileProvider, StartTime } from '@theniledev/react';

const API_URL = 'http://localhost:8080'; // location of the Nile endpoint
const WORKSPACE = 'myWorkspace'; // name of the workspace to use

function App() {
  const filter = {
    entityType: 'clusters',
    metricName: 'my.metric',
  };
  const aggregation = {
    aggregationRequest: {
      startTime: new Date(),
      organizationId: 'myOrganization',
      bucketSize: '1h',
    },
    metricName: 'my.metric',
    aggregationType: 'sum',
  };
  return (
    <NileProvider basePath={API_URL} workspace={WORKSPACE}>
      <h1>ðŸ¤©Metrics the greatðŸ¤©</h1>
      <h2>Requests</h2>
      <StartTime />
      <MetricsLineChart filter={filter} />
      <MetricsLineChart aggregation={aggregation} />
    </NileProvider>
  );
}
```

### MetricsBarChart

A timeseries chart renders a bar graph. Useful for viewing build-in metrics. Provide either a `filter` object or an `aggregation` object depending on what needs to be rendered.

#### Usage

```typescript
import { StartTime, MetricsBarChart, NileProvider } from '@theniledev/react';

const API_URL = 'http://localhost:8080'; // location of the Nile endpoint
const WORKSPACE = 'myWorkspace'; // name of the workspace to use

function App() {
  const filter = {
    entityType: 'clusters',
    metricName: 'my.metric',
  };
  const aggregation = {
    aggregationRequest: {
      startTime: new Date(),
      organizationId: 'myOrganization',
      bucketSize: '1h',
    },
    metricName: 'my.metric',
    aggregationType: 'sum',
  };
  return (
    <NileProvider basePath={API_URL} workspace={WORKSPACE}>
      <h1>ðŸ¤©Metrics the greatðŸ¤©</h1>
      <h2>Requests</h2>
      <StartTime />
      <MetricsBarChart filter={filter} />
      <MetricsBarChart aggregation={aggregation} />
    </NileProvider>
  );
}
```

#### Properties

**dataset** object

- A configuration object to render the line. Maps to [chartjs dataset configuration](https://www.chartjs.org/docs/latest/configuration/#dataset-configuration)

This dataset will vary based on the type of chart.

**updateInterval** number

- time in milliseconds to update the graph. The value can not be lower than 30s. An enum is provided in TypeScript for 30s and 5m.

**chartOptions**

- A configuration object to render the graph. Maps to [chartjs chart configuration](https://www.chartjs.org/docs/latest/configuration/#configuration-object-structure)

## Hooks

It is expected that the basic charts provided by this library will not meet the needs of every use case. For custom charts, the `useFilter` and/or the `useAggregation` hooks can be used to request and format data, and then iterated on.

### useFilter

Assuming a metric is being produced of uptime 1 being up and 0 being down...

```typescript
function MyMetricComponent() {

  const { metrics } = useFilter({
    updateInterval: 30000, // minimum value is 30s
    filter: {
      startTime: new Date(), // start reading metrics from right now
      metricName: 'uptime',
      entityType: 'DB',
    },
  });

  return (
    <div>
      {metrics?.map((metric, idx)=> {
        if (metric.value === 0) {
          return <div key={idx}>ðŸ¤ª Oh nooo! It's broked ðŸ¤ª</div>;
        }
        return (
          <div key={idx}>
            This is working <strong>very</strong> well
          </div>
        );
      })}
    </div>
    );
  }
}
```

### useAggregation

```typescript
function MyMetricComponent() {

  const { buckets } = useAggregation({
    aggregationRequest: {
      startTime: new Date(),
      organizationId: 'myOrganization',
      bucketSize: '1h',
    },
    metricName: 'my.metric',
  });

  return (
    <div>
      {buckets?.map((bucket, idx)=> {
        return (
          <div key={idx}>
            min: {bucket.min}
            max: {bucket.max}
            sum: {bucket.sum}
            average: {bucket.average}
            percentile95: {bucket.percentile95}
          </div>
        );
      })}
    </div>
    );
  }
}
```
